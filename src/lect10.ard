\import Utils
\import lect06_orig

-- 1. Вселенные, полиморфизм по уровням.

-- Тип \Type0 содержит все типы, которые не упоминают \Type0.
-- Тип \Type1 содержит все типы, которые могут упоминать \Type0, но не \Type1.
-- И так далее. Тип \Type n содержит все типы, которые упоминают только \Type i для i < n.
-- Тип \Type i называется вселенной, а число i называется уровнем вселенной.
\func ttt : \Type2 => \Type0 -> \Type1

-- У каждого определения есть неявный параметр-уровень, к которому можно обратиться, написав \lp.
-- Например, функция id, определенная выше, эквивалентна такому определению:
\func id_ (A : \Type \lp) (a : A) => a

-- Когда мы пишем \Type без указания уровня, тайпчекер сам выводит минимальный подходящий уровень.
\func type : \Type => \Type

-- Например, в примере выше у \Type, который написан в теле функции, будет выведен уровень \lp.
-- У \Type, который написан в типе, уровень \lp не может быть, так как не верно, что \Type \lp : \Type \lp, поэтому он будет на 1 выше, то есть \suc \lp.
\func type_ : \Type (\suc \lp) => \Type \lp

\func lift (A : \Type0) : \Type1 => A

-- На уровнях есть небольшой набор операций:
-- * Любое натуральное число является уровнем
-- * \suc l
-- * \max l1 l2
-- То есть любой уровень является либо константой, либо эквивалентен уровню вида \max (\lp + c) c', где c и c' -- константы, а \lp + c -- это уровень вида \suc (\suc ... (\suc \lp) ... ).
-- Уровень пи-типов и других конструкций над типами -- это максимум из уровней типов, входящих в эту конструкцию.
\func test0 : \Type (\max (\suc (\suc \lp)) 4) => \Type (\max \lp 3) -> \Type (\suc \lp)

-- 2. Гомотопическая иерархия.

\func ex1 : \Set => Nat

\func ex3 {A : \Set} (a a' : A) : \Prop => a = a'

-- У нас есть специальная вселенная \Prop, состоящая из типов, удовлетворяющих предикату isProp, то есть из утверждений.
\func isProp (A : \Type) => \Pi (x y : A) -> x = y

-- Мы можем построить биекцию между \Prop и \Sigma (A : \Type) (isProp A).
-- В одну сторону легко построить функцию, так как любой элемент \Prop является типом и в прелюдии объявленая функция, утверждающая, что любой такой тип является утверждением.
-- Чтобы построить функцию в другую сторону и доказать, что они взаимообратны, нужно использовать некоторую языковую конструкцию, которую мы не будем обсуждать.
\func Prop1-to-Prop2 (P : \Prop) : \Sigma (A : \Type) (isProp A) => (P, Path.inProp)

-- Вселенная \Set n эквивалентна \Sigma (A : \Type n) (isSet A).
\func isSet (A : \Type) => \Pi (x y : A) -> isProp (x = y)

-- Для равенств есть следующее правило.
-- Если A : \(n+1)-Type и a,a' : A, то a = a' : \n-Type
-- Таким оразом, мы можем доказать, что любой элемент \Set удовлетворяет предикату isSet при помощи Path.inProp следующим образом.
-- Многие индуктивные определения попадают во вселенную \Set.
-- Таким образом, мы можем доказать, что они удовлетворяют isSet, при помощи Path.inProp.
-- Например, таким образом легко доказать, что Nat удовлетворяет ему.
\func Set1-to-Set2 (P : \Set) : \Sigma (A : \Type) (isSet A)
  => (P, \lam x y => Path.inProp {x = y})

-- Типы параметризованы двумя уровнями.
-- Про первый мы уже говорили раньше.
-- Мы будем называть его предикативным уровнем.
-- Второй называется гомотопическим уровнем.

-- Его можно указывать вторым аргументом к \Type или перед Type.
\func bak => \Type 30 66
\func bak' => \66-Type 30

-- Гомотопический уровень начинается не с 0, а с -1, но вселенная с этим уровнем обозначается просто \Prop.
-- У этой вселенной нет предикативного уровня.
\func foo => \Prop

-- У всех остальных вселенных есть оба уровня.
-- Для вселенных, имеющих гомотопический уровень 0, есть специальный синтаксис.
-- Вместо \Type n 0 можно писать \Set n.
\func bar => \Type 30 0
\func bar' => \Set 30

-- LEM

\func LEM (P : \Prop) : Decide P => {?}

-- 3. Леммы.

-- Лемма -- это функция, которая возвращает утверждение и не вычисляется.
\lemma someLemma (x : Nat) : x = x
  => idp

-- Это работать не будет, т.к. Nat не является утверждением.
-- \lemma notALemma (x : Nat) : Nat => x

-- И это работать не будет, т.к. someLemma не вычисляется.
-- \func doesNotWork (x : Nat) : someLemma x = idp => idp

\func works (x : Nat) : someLemma x = idp => Path.inProp _ _

-- 4. \truncated \data, пропозициональное обрезание.

-- Еще одна новая конструкция: \truncated \data.
-- Она позволяет поместить \data в любой гомотопический уровень.
-- У типа данных, объявленного таким образом, есть одно ограничение.
-- Когда определяется рекурсивная фунция над ним, ее кодомен должен лежать в указанной вселенной.
\truncated \data Trunc (A : \Type) : \Prop
  | trunc A

-- Про Trunc A можно думать как про тип, в котором были объединены все элементы A.
-- Если A был населен, то и Trunc A будет населен.
-- Если A был пуст, то и Trunc A будет пуст.

-- Элиминироваться из Trunc можно только если тип результата является утверждением.
\func Trunc-elim {A : \Type} {B : \Prop} (f : A -> B) (a : Trunc A) : B \elim a
  | trunc a => f a
  -- Trunc-elim (trunc a) === f a

-- Например, мы не можем определить функцию ex1, так как Nat не лежит во вселенной \Prop.
-- \func ex4 (t : Trunc Nat) : Nat
--   | trunc n => n

-- Но мы можем определить ex2, так как 0 = 0 лежит во вселенной \Prop.
\func ex2 (t : Trunc Nat) : 0 = 0
  | trunc n => idp

-- Trunc A называется (пропозициональным) обрезанием A.
-- Trunc A -- это утверждение, верное тогда и только тогда, когда тип A населен.
-- Если A населен, то очевидно и Trunc A населен.

-- Докажем, что Trunc Empty пуст.
-- Это легко сделать, так как Empty является утверждением.
\func Trunc-Empty (t : Trunc Empty) : Empty \elim t
  | trunc a => a

-- Тип данных будет находится во вселенной \Prop, если у него максимум один конструктор и типы всех параметры этого конструктора лежат в \Prop.
-- Например, T лежит в \Prop.
\data T' (b : Bool) \with
  | true => tt

\func T'-test (b : Bool) : \Prop => T' b

\func T-test (b : Bool) : \Prop => T b

-- Trunc обладает следующими свойствами, которые характеризуют его.
-- Т.е. любой тип, обладающий этипи свойствами будет равен Trunc A.
-- 1. isProp (Trunc A)
-- 2. i : A -> Trunc A
-- 3. isProp B -> \Pi (f : A -> B) -> \Sigma (g : Trunc A -> B) (g `o` i = f)

-- Trunc можно задать и без дополнительных конструкций.

\func Nat-church => \Pi (X : \Type) -> (X -> X) -> X -> X

\func Trunc' (A : \Type) : \Prop => \Pi (X : \Prop) -> (A -> X) -> X

\func trunc' {A : \Type} (a : A) : Trunc' A => \lam X f => f a

\func Trunc'-elim {A : \Type} {B : \Prop} (f : A -> B) (a : Trunc' A) : B
  => a B f

-- 5. Или, существует.

-- Теперь мы можем определить операции "или" и "существует" над утверждениями.
-- Мы можем определить "или" как обрезание Either, либо через \truncated \data.
-- \data Either (A B : \Type) | inl A | inr B
-- \func \fixr 2 Or (A B : \Prop) : \Prop => Trunc (Either A B)

\truncated \data \fixr 2 Or (A B : \Type) : \Prop
  | inl A
  | inr B

-- "Или" должен удовлетворять трем свойствам:
-- 1. A -> A `Or` B
-- 2. B -> A `Or` B
-- 3. Для любого утверждения C если A -> C и B -> C, то A `Or` B -> C.
-- Первые два свойства -- это просто конструкторы Or, а последнее -- это просто его рекурсор:
\lemma Or-rec {A B C : \Prop} (f : A -> C) (g : B -> C) (p : A `Or` B) : C \elim p
  | inl a => f a
  | inr b => g b

-- "Существует" тоже легко определяется через Trunc:
\func exists (A : \Type) (B : A -> \Prop) => Trunc (\Sigma (x : A) (B x))

-- P : Nat -> \Prop
-- P -- decidable
-- Trunc (\Sigma (n : Nat) (P n)) -> \Sigma (n : Nat) (P n)

-- isProp (\Sigma (n : Nat) (P n) (\Pi (m : Nat) -> P m -> n <= m))

-- 6. Предикат "тип не пуст".

\data Unit | unit

-- В логике первого порядка утверждение о том, что множество A населено, определяется как "существует a : A такой, что верно истинное утверждение".
-- Мы можем повторить это определение:
\func isInhabited' (A : \Type) : \Prop => exists A (\lam _ => Unit)

-- Но у нас есть более простой вариант (который эквивалентен предыдущему определению):
\func isInhabited (A : \Type) : \Prop => Trunc A

-- 7. Образ функции.

\func image' {A B : \Type} (f : A -> B) => \Sigma (b : B) (\Sigma (a : A) (f a = b))
-- image' {A} {B} f == A
-- image' {Nat} {\Sigma} (\lam _ => ()) == Nat

\func image {A B : \Type} (f : A -> B) => \Sigma (b : B) (Trunc (\Sigma (a : A) (f a = b)))
-- image {Nat} {\Sigma} (\lam _ => ()) == \Sigma

-- 8. Равенство типов, iso.

-- Мы раньше задавались вопросом когда равны два элемента некоторого типа.
-- Например, мы видели, что две пары равны тогда и только тогда, когда они равны покомпонентно.
-- Две функции равны тогда и только тогда, когда они равны поточечно.
-- Мы можем предложить такую характеризацию для всех типов кроме \Type.

-- Посмотрим на примеры равенств между типами.
-- Можем ли мы доказать, что следующие равенства верны или ложны?
-- ? : Maybe Unit = Bool
-- ? : (\Sigma Nat Nat) = Nat
-- ? : Bool = Nat
-- Для первых двух мы ничего не можем доказать, а про последнее мы можем доказать, что оно ложно.
-- Причина заключается в том, что A = B влечет, что между A и B есть биекция, а между Bool и Nat не может быть биекции.

-- Таким образом, естественно сказать, что два типа равны, если между ними есть биекция.
-- Мы будем использовавть слово "биекция" только для множеств, а для произвольных типов мы будем говорить "эквивалентность", но определение этого понятия такое же.

\func Equiv' (A B : \Type) => \Sigma (f : A -> B)
                                     (g : B -> A)
                                     (\Pi (x : A) -> g (f x) = x)
                                     (\Pi (y : B) -> f (g y) = y)

-- p : A = B
-- transport (\lam X => X) p : A -> B

-- Мы можем показать, что если A = B, то между ними есть эквивалентность.
\func equality=>equivalence (A B : \Type) (p : A = B) : Equiv' A B =>
  transport (Equiv' A) p (\lam x => x, \lam x => x, \lam x => idp, \lam x => idp)

-- Функция iso, определенная в прелюдии, говорит, что верно и обратное.
\func equivalence=>equality (A B : \Type) (e : Equiv' A B) : A = B =>
  path (iso e.1 e.2 e.3 e.4)

-- Если у нас есть эквивалентность f : A -> B, то мы можем написать следующую функцию:
-- \lam a => coe (iso f g p q) a right : A -> B
-- Равна ли эта функция исходной f?
-- Ответ: да, так как для coe есть следующее правило:
-- coe (iso f g p q) a right == a

\func transport {A : \Type} (B : A -> \Type) {a a' : A} (p : a = a') (b : B a) : B a'
  => coe (\lam i => B (p @ i)) b right

-- Мы можем переписать это правило через transport вместо coe:
\func test (A B : \Type) (e : Equiv' A B)
  : transport (\lam X => X) (equivalence=>equality A B e) = e.1
  => idp

-- Мы хотим не только, чтобы Equiv A B -> A = B, но и чтобы тип A = B был эквивалентен типу функций, являющимися эквивалентностями.
-- Правило, описанное выше позволяет доказать эту эквивалентность в одну сторону.
-- Ее можно доказать и в обратную (почти), но это доказательство я приводить не буду.
-- Эта аксиома потребуется в ДЗ, ее можно взять в Equiv.Univalence(univalence)

-- 8. Пример применения унивалентности.

-- Пусть у нас есть некоторый предикат
-- P : (A -> B) -> \Type
-- Пусть у нас есть две функции f и g, которые равны поточечно.
-- Правда ли, что если верно P f, то верно и P g?
-- ? : P f -> P g

-- Так как у нас есть функциональная экстенсиональность, то поточечное равенство функций влечет, что они равны, а следовательно для них верны одни и те же свойства.
-- Если бы у нас ее не было, мы не могли бы доказать этот факт.

-- Для типов можно задать аналогичный вопрос.
-- Унивалентность позволяет нам, доказав какое-то утверждение для одного типа, получить его доказателсьтво для любого равномощного ему.
-- Например, мы знаем, что равенство на Nat разрешимо.
-- Отсюда следует, что равенство на любой счетном множестве тоже разрешимо.
-- Мы можем доказать это и без унивалентности, но доказательство будет сложнее и для каждого предиката нужно выписывать своё доказательство, и существуют предкаты, для которых это вообще не верно без унивалентности.

\data Dec (E : \Type)
  | yes E
  | no (Not E)

\func DecEq (A : \Type) => \Pi (x y : A) -> Dec (x = y)

\func NatDecEq : DecEq Nat => {?} -- Мы это доказывали ранее.

\func isCountable (X : \Type) => Equiv' Nat X

\func countableDecEq (X : \Type) (p : isCountable X) : DecEq X =>
  transport DecEq (equivalence=>equality Nat X p) NatDecEq

-- 9. Пропозициональная экстенсиональность.

-- Частный случай унивалентности -- это экстенсиональность для утверждений.
-- Чтобы доказать, что два утверждения равны, достаточно доказать, что одно влечет второе, и второе влечет первое.

\func propExt {A B : \Prop} (f : A -> B) (g : B -> A) : A = B
  => equivalence=>equality A B (f, g, \lam x => Path.inProp _ _, \lam y => Path.inProp _ _)